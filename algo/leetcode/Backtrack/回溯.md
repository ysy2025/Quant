例如，输入集合 {3,4,5}\{3, 4, 5\}{3,4,5} 和目标整数 999 ，解为 {3,3,3},{4,5}\{3, 3, 3\}, \{4, 5\}{3,3,3},{4,5} 。需要注意两点：

输入集合中的元素可以被无限次重复选取。
子集是不区分元素顺序的，比如 {4,5}\{4, 5\}{4,5} 和 {5,4}\{5, 4\}{5,4} 是同一个子集。
向「全排列」代码输入数组 [3,4,5][3, 4, 5][3,4,5] 和目标元素 999 ，输出结果为 [3,3,3],[4,5],[5,4][3, 3, 3], [4, 5], [5, 4][3,3,3],[4,5],[5,4] 。
虽然成功找出了所有和为 999 的子集，但其中存在重复的子集 [4,5][4, 5][4,5] 和 [5,4][5, 4][5,4] 。

这是因为搜索过程是区分选择顺序的，然而子集不区分选择顺序。如下图所示，先选 444 后选 555 与先选 555 后选 444 是两个不同的分支，但两者对应同一个子集。


为了去除重复子集，一种直接的思路是对结果列表进行去重。但这个方法效率很低，因为：

当数组元素较多，尤其是当 target 较大时，搜索过程会产生大量的重复子集。
比较子集（数组）的异同非常耗时，需要先排序数组，再比较数组中每个元素的异同。

重复子集剪枝：
我们考虑在搜索过程中通过剪枝进行去重。观察下图，重复子集是在以不同顺序选择数组元素时产生的，具体来看：

第一轮和第二轮分别选择 333 , 444 ，会生成包含这两个元素的所有子集，记为 [3,4,⋯ ][3, 4, \cdots][3,4,⋯] 。
若第一轮选择 444 ，则第二轮应该跳过 333 ，因为该选择产生的子集 [4,3,⋯ ][4, 3, \cdots][4,3,⋯] 和 1. 中生成的子集完全重复。
分支越靠右，需要排除的分支也越多，例如：

前两轮选择 333 , 555 ，生成子集 [3,5,⋯ ][3, 5, \cdots][3,5,⋯] 。
前两轮选择 444 , 555 ，生成子集 [4,5,⋯ ][4, 5, \cdots][4,5,⋯] 。
若第一轮选择 555 ，则第二轮应该跳过 333 和 444 ，因为子集 [5,3,⋯ ][5, 3, \cdots][5,3,⋯] 和子集 [5,4,⋯ ][5, 4, \cdots][5,4,⋯] 和 1. , 2. 中生成的子集完全重复。

https://leetcode.cn/problems/combination-sum/solutions/2363929/39-zu-he-zong-he-hui-su-qing-xi-tu-jie-b-9zx7/


https://leetcode.cn/studyplan/selected-coding-interview/