抽象基类设计的一致性
0.
    python标准库,为若干容器类的特性提供了抽象基类,python为内置的容器类,例如list,map,set,提供了一致的框架
    标准库,为数值类型提供了ABC.
    collections.abc模块->抽象基类的概念
    3个设计原则:封装,扩展,创建.

4.1. abc
    抽象基类,核心定义在一个abc的模块中;包含了,创建抽象基类需要的修饰符和元类型.

    python3.3之后,迁移到collections.abc中

    介绍numbers模块,包含了数值类型的,抽象基类的,定义.io模块包含了I/O的抽象基类

    一个abc,具有以下特点:
        抽象意味着这些类中不包括我们需要的所有方法的定义;为了让它work,需要提供一些方法定义
        基类意味着,其他类把他当做基类使用
        抽象类,本身提供了一些方法的定义.此外,抽象基类,为确实的方法函数,提供了方法签名.子类必须提供正确方法来创建具体类

    抽象类的特性:
        用它们为python的内部类和程序中的自定义类,定义一组一致的基类
        用它们创建一些通用的可以重复使用的抽象
        用它们支持适当类检查

    如果没有抽象基类,一个容器不一定能够为sequence类提供一致的特性.

    使用abc,可以保证一个给定的类,会有所有的我们预期的行为;如果这个类,没有实现其中的一个特性,那么未定义的抽象方法,会造成无法使用这个类构件对象实例.

    使用abc的三种情况:
        自定义类的时候,使用抽象基类作为基类
        使用抽象基类,来确保一种操作是可行的
        诊断信息或者异常中使用抽象基类来指出一种操作为什么不能生效

4.2. 基类和多态
    过度使用 isinstance 来区分参数的类型,带来复杂性,同时会降低效率
    单元测试,能够更加有效发现代码中的错误

    包含许多isinstance方法的函数可以被认为是糟糕的多态的实现的标志.
    相比于在类的外部处理类型相关的操作,更好的方式是扩展,或者封装

    isinstance,用来诊断信息,和assert结合用更好

    请求原谅比请求许可更好.用raise不如用try-except

4.3 可调用对象
    python中,可调用对象的定义,包括显式使用def语句创建函数;同时包含了,任何定义了__call__()方法的类;
    如果,要让这样的类,成为更加正规的可调用的对象,应该让所有的可调用对象继承自,collections.abc.Callable

4.4 容器和集合
    collections模块也定义了许多集合,这些容器类包括,namedtuple(),deque,ChainMap,Counter,OrderedDict,defaultdict
    所有这些类都是基于抽象类定义类的例子

4.5 数值类型
    需要创建新的数值类型,或者扩展现有的数值类型时,numbers模块,包含了python内置数值类型的抽象定义,从最简单的数值类型到最复杂的,共同构成了庞大的层次结构.
    numbers.Number抽象基类,定义了所有数值以及类数值类型,使用以下代码介绍
    这个基类的子类,包括 Complex,Real,Rational,Integer,类似数学分类
    但是decimal.Decimal和其他不同
    Decimal与其他类型都无关

4.6 其他抽象基类
    迭代器Iterator
    for语句使用可迭代的容器时,Python会隐形创建迭代器
    iter,剖析Python使用的隐形迭代器
    创建一个机遇列表对象的迭代器,然后调用next函数来遍历列表中的值
    最后的isinstance表达式,确定了这个迭代器对象时Iterator的一个实例

    上下文和上下文管理器:with
    Contextlib模块提供了一些,用于创建上下文管理器的工具.没有提供任何abc,而是提供了装饰器和contextlib.ContextDecorator基类,其中装饰器会将简单地函数转换成上下文管理器
    contextlib.ContextDecorator可以被扩展然后创建上下文管理器类

4.7 abc
    ABCMeta类提供了一些有用的特性
    ABCMeta保证抽象基类不可以被实例化;但是提供了所有必须实现的子类可以被实例化.
