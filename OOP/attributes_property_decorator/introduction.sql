属性访问的5种方法
    内部集成属性处理方式->最简单的
    @property,修饰符,特性扩展了属性的概念,包含了方法的处理
    底层的特殊方法来控制属性的访问:__getattr__(),__setattr__(),__delattr__()
    使用__getattribute__()方法在更细粒度层面上操作属性
    介绍一些修饰符,用于属性访问
    默认方法

3.1 属性基本操作
    4种操作,创建,赋值,获取值,删除属性
    添加,修改,删除属性;如果视图获取一个未赋值的属性,或者删除一个不存在的属性时,报错

    另一中更好的方法是从,types.SimpleNamespace类创建实例,此时不需要额外定义一个新类,就能实现同样功能

    特性和init方法
        理想情况下,在init方法中提供所有属性的默认值
        init方法中,没必要为所有属性赋值;一个特性的存在与否构成了对象状态的一部分
    可选择性,更好完善了类定义.
    可选择性,隐藏了一种非正式的子类关系

3.2 创建特性
    特性是一个函数,语法上看起来就是一个简单的属性,可以获取,设置,删除,看起来和属性没有区别
    但是,特性是一个函数,而且可以被调用,而不仅仅是存储对象的引用

    除了复杂程度,特性和属性的区别->我们不能轻易为已有的对象添加新特性,但是添加新属性不难
    两种方式创建特性:@property;property函数

    特性的两种基本设计模式:
        主动计算:更新特性值,其他相关特性就立即重算
        延迟计算:仅当访问特性时,才触发计算过程

    主动计算特性

    赋值更加显然的体现了代码意图

    setter和getter
    @property就是getter
    @xx.setter是setter
    @xx.deleter是删除器

3.3 使用特殊方法完成属性访问
    getattr,setattr,delattr,dir查看属性名称;getattribute

    关于属性,几种默认操作
    setattr,创建属性和赋值
    getattr,已有值,则获取值,没有值,则赋值
    dir,用于返回属性名称列表

    注意扩展,封装,创建
    扩展类,通过重写 __getattr__(),__setattr__(),__delattr__(),使得它几乎是不可变的;也可以使用 __slot__() 替换内部的 __dict__
    封装类,提供对象或者对象集合属性访问的代理实现->可能需要完全重写和属性相关的函数
    创建类并提供和特性功能一样的函数->用来对特性逻辑集中处理

    创建延迟计算->getattr
    创建主动计算->setattr

    使用__slot__创建不可变对象

    使用tuple子类创建不可变对象
        通过让card特性成为tuple子类的对象,重写 getattr函数来实现一个不可变对象, getattr->self[index]

